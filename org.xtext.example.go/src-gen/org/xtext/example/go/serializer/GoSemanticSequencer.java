/*
 * generated by Xtext 2.14.0
 */
package org.xtext.example.go.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.go.go.Anderson;
import org.xtext.example.go.go.Assig;
import org.xtext.example.go.go.Block;
import org.xtext.example.go.go.Decl;
import org.xtext.example.go.go.ForClause;
import org.xtext.example.go.go.ForStmt;
import org.xtext.example.go.go.FuncDecl;
import org.xtext.example.go.go.GoPackage;
import org.xtext.example.go.go.Model;
import org.xtext.example.go.go.SelectStmt;
import org.xtext.example.go.go.SimpleStmt;
import org.xtext.example.go.go.SourceFile;
import org.xtext.example.go.go.Statement;
import org.xtext.example.go.go.StatementList;
import org.xtext.example.go.go.SwitchCase;
import org.xtext.example.go.go.TopLevelDecl;
import org.xtext.example.go.services.GoGrammarAccess;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.ANDERSON:
				if (rule == grammarAccess.getAndersonRule()) {
					sequence_Anderson(context, (Anderson) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStmtRule()
						|| rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getLabeledStmtRule()) {
					sequence_Anderson_IfStmt(context, (Anderson) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()) {
					sequence_Anderson_SwitchStmt(context, (Anderson) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.ASSIG:
				sequence_Assig(context, (Assig) semanticObject); 
				return; 
			case GoPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case GoPackage.DECL:
				sequence_Decl(context, (Decl) semanticObject); 
				return; 
			case GoPackage.FOR_CLAUSE:
				if (rule == grammarAccess.getForStmtRule()
						|| rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getLabeledStmtRule()) {
					sequence_Assig_ForClause_ForStmt(context, (ForClause) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForClauseRule()) {
					sequence_Assig_ForClause_SimpleStmt(context, (ForClause) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.FOR_STMT:
				sequence_ForStmt(context, (ForStmt) semanticObject); 
				return; 
			case GoPackage.FUNC_DECL:
				sequence_FuncDecl(context, (FuncDecl) semanticObject); 
				return; 
			case GoPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GoPackage.SELECT_STMT:
				sequence_SelectStmt(context, (SelectStmt) semanticObject); 
				return; 
			case GoPackage.SIMPLE_STMT:
				sequence_SimpleStmt(context, (SimpleStmt) semanticObject); 
				return; 
			case GoPackage.SOURCE_FILE:
				sequence_SourceFile(context, (SourceFile) semanticObject); 
				return; 
			case GoPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case GoPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case GoPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case GoPackage.TOP_LEVEL_DECL:
				sequence_TopLevelDecl(context, (TopLevelDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Anderson returns Anderson
	 *
	 * Constraint:
	 *     (decl=Decl | Assig=Assig)?
	 */
	protected void sequence_Anderson(ISerializationContext context, Anderson semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStmt returns Anderson
	 *     Statement returns Anderson
	 *     LabeledStmt returns Anderson
	 *
	 * Constraint:
	 *     ((decl=Decl | Assig=Assig)? Block+=Block (IfStmt=IfStmt | Block+=Block)?)
	 */
	protected void sequence_Anderson_IfStmt(ISerializationContext context, Anderson semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns Anderson
	 *
	 * Constraint:
	 *     ((decl=Decl | Assig=Assig)? SwitchCase+=SwitchCase* SwitchCase+=SwitchCase*)
	 */
	protected void sequence_Anderson_SwitchStmt(ISerializationContext context, Anderson semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assig
	 *     LabeledStmt returns Assig
	 *     Assig returns Assig
	 *     SimpleStmt returns Assig
	 *
	 * Constraint:
	 *     (id=ID ((idl=IdList expression=Exp expressionlist=ExpList) | expression=Exp)?)
	 */
	protected void sequence_Assig(ISerializationContext context, Assig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForStmt returns ForClause
	 *     Statement returns ForClause
	 *     LabeledStmt returns ForClause
	 *
	 * Constraint:
	 *     (decl=Decl? (id=ID ((idl=IdList expression=Exp expressionlist=ExpList) | expression=Exp)?)? Block=Block)
	 */
	protected void sequence_Assig_ForClause_ForStmt(ISerializationContext context, ForClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForClause returns ForClause
	 *
	 * Constraint:
	 *     (decl=Decl? ((id=ID ((idl=IdList expression=Exp expressionlist=ExpList) | expression=Exp)?) | decl=Decl)?)
	 */
	protected void sequence_Assig_ForClause_SimpleStmt(ISerializationContext context, ForClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     Statement+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Decl
	 *
	 * Constraint:
	 *     (name=ID | (name=ID idList=IdList type=TypeName (exp=Exp explist=ExpList)?))
	 */
	protected void sequence_Decl(ISerializationContext context, Decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForStmt returns ForStmt
	 *     Statement returns ForStmt
	 *     LabeledStmt returns ForStmt
	 *
	 * Constraint:
	 *     Block=Block
	 */
	protected void sequence_ForStmt(ISerializationContext context, ForStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FOR_STMT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FOR_STMT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStmtAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncDecl returns FuncDecl
	 *
	 * Constraint:
	 *     (receiver=Receiver? name=ID signature=Signature block=Block?)
	 */
	protected void sequence_FuncDecl(ISerializationContext context, FuncDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=SourceFile+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SelectStmt
	 *     SelectStmt returns SelectStmt
	 *     LabeledStmt returns SelectStmt
	 *
	 * Constraint:
	 *     CommClause+=CommClause*
	 */
	protected void sequence_SelectStmt(ISerializationContext context, SelectStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SimpleStmt
	 *     LabeledStmt returns SimpleStmt
	 *     SimpleStmt returns SimpleStmt
	 *
	 * Constraint:
	 *     decl=Decl?
	 */
	protected void sequence_SimpleStmt(ISerializationContext context, SimpleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SourceFile returns SourceFile
	 *
	 * Constraint:
	 *     TopLevelDecl+=TopLevelDecl*
	 */
	protected void sequence_SourceFile(ISerializationContext context, SourceFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommClause returns StatementList
	 *     StatementList returns StatementList
	 *
	 * Constraint:
	 *     Statement+=Statement*
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *     LabeledStmt returns Statement
	 *
	 * Constraint:
	 *     (
	 *         LabeledStmt=LabeledStmt | 
	 *         SendStmt=SendStmt | 
	 *         SwitchStmt=SwitchStmt | 
	 *         ReturnStmt=ReturnStmt | 
	 *         BreakStmt=BreakStmt | 
	 *         ContinueStmt=ContinueStmt | 
	 *         GotoStmt=GotoStmt | 
	 *         FalltrhoughStmt=FalltrhoughStmt | 
	 *         DeferStmt=DeferStmt
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     Statement+=Statement*
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns TopLevelDecl
	 *
	 * Constraint:
	 *     (decl=Decl | func=FuncDecl)?
	 */
	protected void sequence_TopLevelDecl(ISerializationContext context, TopLevelDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
