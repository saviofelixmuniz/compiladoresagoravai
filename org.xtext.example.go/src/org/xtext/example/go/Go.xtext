grammar org.xtext.example.go.Go with org.eclipse.xtext.common.Terminals

generate go "http://www.xtext.org/example/go/Go"

Model:
	element=SourceFile
;

SourceFile:
	{SourceFile} Package ";"? (ImportDecl ";"?)* (TopLevelDecl+=TopLevelDecl ";"?)*
;

TopLevelDecl:
	{TopLevelDecl} (decl=Decl | func=FuncDecl | typeDef=TypeDef)
;

ImportDecl:
	"import" (ImportSpec | ("(" (ImportSpec ";"?)* ")"))
;

ImportSpec:
	("." | ID)? STRING
;

Package:
	"package" ID
;

ForStmt:
	"for" (Exp range=RangeClause? | ForClause?) Block=Block
;

ForClause:
	{ForClause} (forDecl=Decl)? ";" forExp=Exp? ";" stmt=SimpleStmt?
;

RangeClause:
	(ExpList (":="|"="))? "range" rangeExp=Exp
;

FunctionType:
	"func" Signature
;

FuncDecl:
	"func" receiver=Receiver? name=ID signature=Signature block=Block?
;

Receiver:
	params=Parameters
;

Signature:
	params=Parameters result=Result?
;

Result:
	Parameters | TypeName 
;

Parameters:
	{Parameters} "(" (paramList=ParameterList ","?)? ")"
; 

ParameterList:
	firstparam=ParameterDecl ("," params+=ParameterDecl)*
;

ParameterDecl:
	(name=ID IdList)? "..."? type=TypeName
;

SwitchStmt:
	"switch" Anderson ID? "{" (("case" exp+=Exp SwitchCase+=SwitchCase)*  ("default" SwitchCase+=SwitchCase* )?) "}"
;

SwitchCase:
	{SwitchCase} ":" (Statement+=Statement ";"? )*
;

IfStmt:
	"if" anderson=Anderson ifRelExp=Exp ifBlock=Block ("else" (ifStmt=IfStmt | elseBlock=Block))?
;

Anderson:
	{Anderson} ((decl=Decl | Assig=Assig | andersonExp=Exp) ";")?
;

Block:
	{Block} "{" (statements+=Statement ";"? )* "}"
;

Statement:
 	LabeledStmt=LabeledStmt | SendStmt=SendStmt | simpleStmt=SimpleStmt | ifstmt=IfStmt | SwitchStmt=SwitchStmt | ReturnStmt=ReturnStmt | ForStmt | 
	BreakStmt=BreakStmt | ContinueStmt=ContinueStmt | GotoStmt=GotoStmt | 
	FalltrhoughStmt=FalltrhoughStmt | DeferStmt=DeferStmt | SelectStmt
;

SelectStmt:
	{SelectStmt} "select" "{" CommClause+=CommClause* "}"
;

CommClause:
	CommCase ":" stmList=StatementList
;

StatementList:
	{StatementList} (Statement+=Statement ";"?)*
;

CommCase:
	("case" (SendStmt | RecvStmt)) | "default"
;

RecvStmt:
	((exp=Exp list=ExpList "=") | (ID IdList ":="))? exp=Exp
;

LabeledStmt:
	ID ":" Statement
;

SendStmt:
	exp=Exp "<-" otherExp=Exp
;

BreakStmt:
	"break" ID? ";"?
;

ContinueStmt:
	"continue" ID? ";"?
;

GotoStmt:
	"goto" ID? ";"?
;

FalltrhoughStmt:
	"fallthrough" ";"?
;

DeferStmt:
	"defer" Exp ";"?
;

ReturnStmt:
	"return" Exp?
;

TypeDef:
	"type" name=ID typeName=TypeName
;

Struct:
	{Struct} "struct" "{" (fieldDecls+=FieldDecl ";"?)* "}"
;

FieldDecl:
	name=ID type=TypeName
;

Decl:
	{ShortVar} (name=ID IdList ":=" exp=Exp list=ExpList) | {Var} (("var" | "const") name=ID idList=IdList type=TypeName ("=" exp=Exp explist=ExpList)?)
;

Assig :
	id=ID ((idl=IdList "=" expression=Exp expressionlist=ExpList) | ("++"|"--") | (("+="|"-="|"*="|"/=") expression=Exp))
;

IdList:
	("," ID)*
;

ExpList:
	{ExpList} ("," exps+=Exp)*
;

Exp: 
	call=Call | aux=ExpAux | boolean=BooleanExp join=ExpJoin? | rel=RelExp | arit=AritExp join=ExpJoin? | literalString=STRING | name=ID join=ExpJoin?
;

ExpJoin:
	operator=(OP_UNARY | OP_REL | OP_SUM | OP_MULT | "&&" | "||") exp=Exp
;

SimpleStmt:
	decl=Decl | Assig | exp=Exp 
;

ExpAux:
	"!"? "(" exp=Exp ")" (join=ExpJoin)? 
;

Call:
	name=ID ("." ID)* "(" (exp=Exp explist=ExpList)? ")"
;


RelExp:
	NumberLiteral (OP_REL | OP_UNARY) NumberLiteral | BooleanLiteral OP_UNARY BooleanLiteral
;

BooleanExp:
	 Or	
;

Or:
	"!"? And ('||' And)*
;

And:
	BooleanLiteral ('&&' BooleanLiteral)*
;

BooleanLiteral:
	Bool
;

AritExp:
	Addition
;

Addition:
	(OP_SUM? Multiplication)+
;

Multiplication:
	NumberLiteral (OP_MULT? NumberLiteral)*
;

NumberLiteral:
	INT
;

TypeName:
	{TypeName} (basic=BasicTypes | qualified=QualifiedIdent | id=ID | struct=Struct)
;

QualifiedIdent:
	ID "." ID
;

Bool:
	"true" | "false"
;

BasicTypes:
	"string" | "int" | "bool"
;

terminal OP_SUM:
	("+" | "-" | "|" | "^")
;

terminal OP_MULT:
	("*" | "/" | "%" | "<<" | ">>" | "&" | "&^")
;

terminal OP_REL:
	"<=" | ">=" | "<" | ">"	
;

terminal OP_UNARY:
	"==" | "!="	| "<-" | "&"
;
