/*
 * generated by Xtext 2.14.0
 */
package org.xtext.example.go.validation

import org.xtext.example.go.go.Decl
import java.util.HashMap
import org.eclipse.xtext.validation.Check
import java.util.List
import java.util.LinkedList
import org.xtext.example.go.go.TopLevelDecl
import org.xtext.example.go.go.SourceFile
import org.xtext.example.go.go.GoPackage
import org.xtext.example.go.go.FuncDecl
import org.xtext.example.go.go.Exp

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GoValidator extends AbstractGoValidator {

	public static val DUPLICATE_DECLARATION = 'duplicateDeclaration'
	public static val MISMATCHED_TYPE = 'mismatchedType'
	val intOps = #['+', '-', '*', '/', '%', '<=', '<', '>', '>=']
	val boolOps = #['&&', '||', '!']
	val eqOps = #['==', '!=']
	
	@Check
	def checkVarDuplicada(SourceFile sourceFile){
		var decls = sourceFile.topLevelDecl
		
		var map = new HashMap<String, Decl>
		
		for (TopLevelDecl t: decls) {
			var decl = t.decl
			
			if (map.containsKey(decl.name)) {
				error(decl.name + ' já foi declarada', 
					GoPackage.Literals.SOURCE_FILE__TOP_LEVEL_DECL,
					DUPLICATE_DECLARATION)
			}
			else {
				map.put(decl.name, decl)
			}	
		}
	}
	
	@Check
	def checkFuncDuplicada(SourceFile sourceFile){
		var decls = sourceFile.topLevelDecl
		
		var map = new HashMap<String, FuncDecl>
		
		for (TopLevelDecl t: decls) {
			var decl = t.func
			
			if (map.containsKey(decl.name)) {
				error('A função ' + decl.name + ' já foi declarada', 
					GoPackage.Literals.SOURCE_FILE__TOP_LEVEL_DECL,
					DUPLICATE_DECLARATION)
			}
			else {
				map.put(decl.name, decl)
			}	
		}
	}

	@Check
	def checkExpTypes(Exp exp){
		var expMap = new HashMap<Exp, String>

		var currentExp = exp
		var currentJoin = currentExp.join
		if (currentExp.aux !== null) {
			currentJoin = currentExp.aux.join
		}
		while (currentExp !== null) {
			if (currentExp.aux !== null) {
				evaluate(currentExp.aux.exp, currentExp, expMap)
				if (currentJoin === null || currentJoin.exp === null || currentJoin.exp.join === null) {
					evaluateAux(exp, expMap)
				}
			} else {
				if (currentJoin.exp.aux === null) {
					noAuxEvaluate(currentExp)
				}
			}
			
			if (currentJoin === null) {
				return
			}
			currentExp = currentJoin.exp
			currentJoin = currentExp.join
			if (currentExp.aux !== null) {
				currentJoin = currentExp.aux.join
			}
		}
	}
	
	def void noAuxEvaluate(Exp exp) {
		if (exp.arit !== null && ((intOps.contains(exp.join.operator) && (exp.join.exp.boolean !== null ||
			exp.join.exp.literalString !== null || exp.join.exp.rel !== null)) || boolOps.contains(exp.join.operator))
		) {
			error('Operação inválida.', 
				GoPackage.Literals.EXP__JOIN,
				MISMATCHED_TYPE)
		}
		if (exp.boolean !== null && ((boolOps.contains(exp.join.operator) && (exp.join.exp.arit !== null ||
			exp.join.exp.literalString !== null || exp.join.exp.rel !== null)) || 
			intOps.contains(exp.join.operator))
		) {
			error('Operação inválida.', 
				GoPackage.Literals.EXP__JOIN,
				MISMATCHED_TYPE)
		}
	}
	
	def void evaluate(Exp exp, Exp aux, HashMap<Exp, String> map) {
		var currentExp = exp
		var currentJoin = currentExp.join
		if (currentExp.aux !== null) {
			currentJoin = currentExp.aux.join
		}

		if (currentExp.aux !== null) {
			evaluate(currentExp.aux.exp, currentExp, map)
			if (currentExp.aux.exp.arit !== null || (currentExp.aux.join.exp.arit !== null )) {
				map.put(aux, 'int');
			} else if (currentExp.aux.exp.arit !== null || (currentExp.aux.join.exp.boolean !== null )) {
				map.put(aux, 'boolean');
			}
			return
		}
		
		while (currentJoin !== null) {
			if (currentExp.arit !== null && ((intOps.contains(currentJoin.operator) && (currentJoin.exp.boolean !== null ||
				currentJoin.exp.literalString !== null || currentJoin.exp.rel !== null)) || boolOps.contains(currentJoin.operator))
			) {
				error('Operação inválida.', 
					GoPackage.Literals.EXP__JOIN,
					MISMATCHED_TYPE)
			}
			if (currentExp.boolean !== null && ((boolOps.contains(currentJoin.operator) && (currentJoin.exp.arit !== null ||
				currentJoin.exp.literalString !== null || currentJoin.exp.rel !== null)) || 
				intOps.contains(currentJoin.operator))
			) {
				error('Operação inválida.', 
					GoPackage.Literals.EXP__JOIN,
					MISMATCHED_TYPE)
			}
			currentExp = currentJoin.exp
			currentJoin = currentExp.join
			if (currentExp.aux !== null) {
				currentJoin = currentExp.aux.join
			}
		}
		
		if (currentExp.arit !== null) {
			map.put(aux, 'int')
		} else if (currentExp.boolean !== null) {
			map.put(aux, 'boolean')
		}
	}
	
	def evaluateAux(Exp exp, HashMap<Exp, String> expMap) {
		var intOps = #['+', '-', '*', '/', '%', '<=', '<', '>', '>=']
		var boolOps = #['&&', '||', '!']
		var currentExp = exp
		var currentJoin = currentExp.join		
		if (currentExp.aux !== null) {
			currentJoin = currentExp.aux.join
		}
		while (currentExp !== null && currentJoin !== null) {
			println(currentExp)
			println(currentJoin.operator)
			println(currentJoin.exp)
			if (currentJoin.exp.aux !== null || currentExp.aux !== null) {
				if (currentExp.aux !== null && !expMap.containsKey(currentExp)) {
					evaluate(currentExp.aux.exp, currentExp, expMap);
				}
				if (currentJoin.exp.aux !== null && !expMap.containsKey(currentJoin.exp)) {
					evaluate(currentJoin.exp.aux.exp, currentJoin.exp, expMap);
				}
				if (currentJoin.exp.aux !== null && currentExp.aux !== null) {
					if (boolOps.contains(currentJoin.operator)) {
						if(expMap.get(currentExp) !== 'boolean' || expMap.get(currentJoin.exp) !== 'boolean') {
							error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
						}
					} else if (intOps.contains(currentJoin.operator)) {
						if(expMap.get(currentExp) !== 'int' || expMap.get(currentJoin.exp) !== 'int') {
							error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
						}
					}
				} else if (currentJoin.exp.aux !== null && currentExp.aux === null) {
					if ((boolOps.contains(currentJoin.operator) && 
						(expMap.get(currentJoin.exp) !== 'boolean' || currentExp.boolean === null)) ||
						(intOps.contains(currentJoin.operator) && 
						(expMap.get(currentJoin.exp) !== 'int' || currentExp.arit === null))
					) {
						error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
					}
				} else {
					if ((boolOps.contains(currentJoin.operator) && 
						(expMap.get(currentExp) !== 'boolean' || currentJoin.exp.boolean === null)) ||
						(intOps.contains(currentJoin.operator) && 
						(expMap.get(currentExp) !== 'int' || currentJoin.exp.arit === null))
					) {
						error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
					}
				}
			}
			//println('op: ' + currentJoin.operator);
			currentExp = currentJoin.exp
			currentJoin = currentExp.join
			if (currentExp.aux !== null) {
				currentJoin = currentExp.aux.join
			}
		}
	}
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GoPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
}
