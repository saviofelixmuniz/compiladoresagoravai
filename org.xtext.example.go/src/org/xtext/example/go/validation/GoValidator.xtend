/*
 * generated by Xtext 2.14.0
 */
package org.xtext.example.go.validation

import org.xtext.example.go.go.Decl
import java.util.HashMap
import org.eclipse.xtext.validation.Check
import org.xtext.example.go.go.TopLevelDecl
import org.xtext.example.go.go.SourceFile
import org.xtext.example.go.go.GoPackage
import org.xtext.example.go.go.FuncDecl
import org.xtext.example.go.go.Call
import org.xtext.example.go.go.Model
import org.xtext.example.go.go.Exp
import org.xtext.example.go.go.ParameterDecl
import org.xtext.example.go.go.Block
import org.xtext.example.go.go.Statement
import org.xtext.example.go.go.Var
import org.xtext.example.go.go.ShortVar
import org.xtext.example.go.go.FieldDecl
import org.xtext.example.go.go.Struct
import org.xtext.example.go.go.ParameterList

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GoValidator extends AbstractGoValidator {

	public static val DUPLICATE_DECLARATION = 'duplicateDeclaration'
	public static val FUNCTION_404 = 'functionNotFound'
	public static val VAR_404 = 'varNotFound'
	public static val PARAMETERS_ERROR = 'parametersError'
	public static val MISMATCHED_TYPE = 'mismatchedType'
	val intOps = #['+', '-', '*', '/', '%', '<=', '<', '>', '>=']
	val boolOps = #['&&', '||', '!']
	val eqOps = #['==', '!=']

	var Model model
	var HashMap<String, String> ids = new HashMap<String, String>
	var HashMap<String, HashMap<String, String>> funcs = new HashMap<String, HashMap<String, String>>
	var HashMap<String, HashMap<String, String>> structs = new HashMap<String, HashMap<String, String>>
	
	@Check 
	def updateModel(Model model) {
		var HashMap<String, String> localIds = new HashMap<String, String>
		var HashMap<String, HashMap<String, String>> localFuncs = new HashMap<String, HashMap<String, String>>
		var HashMap<String, HashMap<String, String>> localStructs = new HashMap<String, HashMap<String, String>>
		this.model = model
		var globais = model.element.topLevelDecl
		
		for (TopLevelDecl topster : globais) {
			if (topster.decl !== null) {
				var decl = topster.decl
				if (decl instanceof Var) {
					var typeDecl = decl as Var
					localIds.put(decl.name, typeDecl.type.basic)
				} else {
					var type = getTypeFromShortVarDecl(decl as ShortVar, localIds)
					localIds.put(decl.name, type)
				}
			} else if (topster.typeDef !== null && topster.typeDef.typeName.struct !== null) {
				var typeDef = topster.typeDef
				var struct = typeDef.typeName.struct
				if (!localStructs.containsKey(typeDef.name)) {
					var structMap = getStructIds(struct)
					localStructs.put(typeDef.name, structMap)
				} else {
					error(typeDef.name + ' já foi declarado',
					typeDef, 
					GoPackage.Literals.TYPE_DEF__NAME)
				}
			} else if (topster.func !== null) {
				var func = topster.func
				checkMethodReceiver(func)
				if (!localFuncs.containsKey(func.name)) {
					var funcMap = getFuncIds(func)
					localFuncs.put(func.name, funcMap)
				} else {
					error(func.name + ' já foi declarada',
					func, 
					GoPackage.Literals.FUNC_DECL__NAME)
				}
			}
		}
		
		ids = localIds
		funcs = localFuncs
		structs = localStructs
		println(ids)
		println(funcs)
		println(structs)
	}
	
	def void checkMethodReceiver(FuncDecl func) {
		var receiver = func.receiver
		if (receiver === null) return;
		
		var paramList = receiver.params.paramList
		
		if (paramList.firstparam.type.id !== null) {
			if (!structs.containsKey(paramList.firstparam.type.id)) {
				error('O tipo ' + paramList.firstparam.type.id + ' não existe', 
				paramList.firstparam.type,
				GoPackage.Literals.TYPE_NAME__STRUCT)
			}
		}
		for (ParameterDecl pDecl : func.receiver.params.paramList.params) {
			if (pDecl.type.id !== null) {
				if (!structs.containsKey(pDecl.type.id)) {
					error('O tipo ' + pDecl.type.id + ' não existe', 
					pDecl.type,
					GoPackage.Literals.TYPE_NAME__STRUCT)
				}
			}
		}
	}
	
	def HashMap<String, String> getFuncIds(FuncDecl func) {
		var HashMap<String, String> funcIds = new HashMap<String, String>
		for (Statement stmt : func.block.statements) {
			if (stmt.simpleStmt !== null && stmt.simpleStmt.decl !== null) {
				var decl = stmt.simpleStmt.decl
				if (funcIds.containsKey(decl.name)) {
					error(decl.name + ' já foi declarada', 
					decl,
					GoPackage.Literals.DECL__NAME)
				}
				if (decl instanceof Var) {
					var typeDecl = decl as Var
					funcIds.put(decl.name, typeDecl.type.basic)
				} else {
					var type = getTypeFromShortVarDecl(decl as ShortVar, funcIds)
					funcIds.put(decl.name, type)
				}
			}
		}
		return funcIds
	}
	
	def HashMap<String, String> getStructIds(Struct struct) {
		var HashMap<String, String> structIds = new HashMap<String, String>
		for (FieldDecl decl : struct.fieldDecls) {
			if (structIds.containsKey(decl.name)) {
				error(decl.name + ' já foi declarado', 
				decl,
				GoPackage.Literals.FIELD_DECL__NAME)
			} else {
				structIds.put(decl.name, decl.type.basic)
			}

		}
		return structIds
	}

	def String getTypeFromShortVarDecl(ShortVar shortVar, HashMap<String, String> map) {
		var exp = shortVar.exp
		if (exp.arit !== null) return 'int'
		if (exp.boolean !== null) return 'bool'
		if (exp.name !== null) {
			if (map.containsKey(exp.name)) {
				return map.get(exp.name)
			} else if (ids.containsKey(exp.name)) {
				return ids.get(exp.name)
			} else {
				error(exp.name + ' não foi declarada',
					exp, 
					GoPackage.Literals.EXP__NAME)
			}
		}
		if (exp.literalString !== null) {
			return 'string'
		}
		
		
		return ''
	}
	
	@Check
	def checkVarDuplicada(SourceFile sourceFile){
		var decls = sourceFile.topLevelDecl
		
		var map = new HashMap<String, Decl>
		
		for (TopLevelDecl t: decls) {
			var decl = t.decl
			
			if (map.containsKey(decl.name)) {
				error(decl.name + ' já foi declarada', 
					GoPackage.Literals.TOP_LEVEL_DECL__DECL,
					DUPLICATE_DECLARATION)
			}
			else {
				map.put(decl.name, decl)
			}	
		}
	}
	
	@Check
	def checkFuncDuplicada(SourceFile sourceFile){
		var decls = sourceFile.topLevelDecl
		
		var map = new HashMap<String, FuncDecl>
		
		for (TopLevelDecl t: decls) {
			var decl = t.func
			
			if (map.containsKey(decl.name)) {
				error('A função ' + decl.name + ' já foi declarada', 
					GoPackage.Literals.SOURCE_FILE__TOP_LEVEL_DECL,
					DUPLICATE_DECLARATION)
			}
			else {
				if (decl.name !== null) {
					map.put(decl.name, decl)
				}					
			}	
		}
	}
	
	@Check
	def checkFuncCall(Call call){
		var funcName = call.name
		
		var topLevel = model.element.topLevelDecl
		
		var found = false
		for (TopLevelDecl t: topLevel) {
			var itFunc = t.func
			
			if (itFunc.name == funcName) {
				found = true
				var callParams = 0
				if (call.exp !== null)
					callParams++
				
				for (Exp exp: call.explist.exps)
					callParams++
				
				var funcParams = 0
				if (itFunc.signature.params.paramList !== null) {
					funcParams++;
					if (itFunc.signature.params.paramList.params !== null) {
						for (ParameterDecl param: itFunc.signature.params.paramList.params) {
							funcParams++
						}
					}
				} 				
				
				if (callParams !== funcParams)
					error('A função ' + funcName + ' tem ' + funcParams + ' parametros', 
						GoPackage.Literals.CALL__NAME,
						PARAMETERS_ERROR)
			}
		}
		
		if (!found)
			error('A função ' + funcName + ' não existe', 
							GoPackage.Literals.CALL__NAME,
							FUNCTION_404)
	}
	 					
	@Check
	def checkIfElse (Block block) {
		var stmts = block.statements;
		
		for (Statement stmt: stmts) {
			var ifRelExp = stmt.ifstmt.ifRelExp
			var result = false
			if (ifRelExp.aux !== null) {
				result = evaluateRelExp(ifRelExp.aux.exp)
					
			}
			
			else {
				result = evaluateRelExp(ifRelExp)
			}
	
			if(!result)
				error('A expressão deve retornar tipo bool', 
 						GoPackage.Literals.BLOCK__STATEMENTS,
 						FUNCTION_404)
		}			
	}
	
	def evaluateRelExp (Exp exp) {
		if (exp.join !== null && exp.name !== null) {
				if (exp.join.operator != ">" && 
					exp.join.operator != "<" &&
					exp.join.operator != "!=" &&
					exp.join.operator != "=="
 				) {
 					return false
 				}
			}
			
		else if (exp.boolean === null && exp.rel === null) {
			return false
		}
		
		return true
	}
	
	@Check
	def checkExpTypes(Exp exp){
		var expMap = new HashMap<Exp, String>

		var currentExp = exp
		var currentJoin = currentExp.join
		if (currentExp.aux !== null) {
			currentJoin = currentExp.aux.join
		}
		while (currentExp !== null) {
			if (currentExp.aux !== null) {
				evaluate(currentExp.aux.exp, currentExp, expMap)
				if (currentJoin === null || currentJoin.exp === null || currentJoin.exp.join === null) {
					evaluateAux(exp, expMap)
				}
			} else {
				if (currentJoin.exp.aux === null) {
					noAuxEvaluate(currentExp)
				}
			}
			
			if (currentJoin === null) {
				return
			}
			currentExp = currentJoin.exp
			currentJoin = currentExp.join
			if (currentExp.aux !== null) {
				currentJoin = currentExp.aux.join
			}
		}
	}
	
	def void noAuxEvaluate(Exp exp) {
		if (exp.arit !== null && ((intOps.contains(exp.join.operator) && (exp.join.exp.boolean !== null ||
			exp.join.exp.literalString !== null || exp.join.exp.rel !== null)) || boolOps.contains(exp.join.operator))
		) {
			error('Operação inválida.', 
				GoPackage.Literals.EXP__JOIN,
				MISMATCHED_TYPE)
		}
		if (exp.boolean !== null && ((boolOps.contains(exp.join.operator) && (exp.join.exp.arit !== null ||
			exp.join.exp.literalString !== null || exp.join.exp.rel !== null)) || 
			intOps.contains(exp.join.operator))
		) {
			error('Operação inválida.', 
				GoPackage.Literals.EXP__JOIN,
				MISMATCHED_TYPE)
		}
	}
	
	def void evaluate(Exp exp, Exp aux, HashMap<Exp, String> map) {
		var currentExp = exp
		var currentJoin = currentExp.join
		if (currentExp.aux !== null) {
			currentJoin = currentExp.aux.join
		}

		if (currentExp.aux !== null) {
			evaluate(currentExp.aux.exp, currentExp, map)
			if (currentExp.aux.exp.arit !== null || (currentExp.aux.join.exp.arit !== null )) {
				map.put(aux, 'int');
			} else if (currentExp.aux.exp.arit !== null || (currentExp.aux.join.exp.boolean !== null )) {
				map.put(aux, 'bool');
			}
			return
		}
		
		while (currentJoin !== null) {
			if (currentExp.arit !== null && ((intOps.contains(currentJoin.operator) && (currentJoin.exp.boolean !== null ||
				currentJoin.exp.literalString !== null || currentJoin.exp.rel !== null)) || boolOps.contains(currentJoin.operator))
			) {
				error('Operação inválida.', 
					GoPackage.Literals.EXP__JOIN,
					MISMATCHED_TYPE)
			}
			if (currentExp.boolean !== null && ((boolOps.contains(currentJoin.operator) && (currentJoin.exp.arit !== null ||
				currentJoin.exp.literalString !== null || currentJoin.exp.rel !== null)) || 
				intOps.contains(currentJoin.operator))
			) {
				error('Operação inválida.', 
					GoPackage.Literals.EXP__JOIN,
					MISMATCHED_TYPE)
			}
			currentExp = currentJoin.exp
			currentJoin = currentExp.join
			if (currentExp.aux !== null) {
				currentJoin = currentExp.aux.join
			}
		}
		
		if (currentExp.arit !== null) {
			map.put(aux, 'int')
		} else if (currentExp.boolean !== null) {
			map.put(aux, 'bool')
		}
	}
	
	def evaluateAux(Exp exp, HashMap<Exp, String> expMap) {
		var intOps = #['+', '-', '*', '/', '%', '<=', '<', '>', '>=']
		var boolOps = #['&&', '||', '!']
		var currentExp = exp
		var currentJoin = currentExp.join		
		if (currentExp.aux !== null) {
			currentJoin = currentExp.aux.join
		}
		while (currentExp !== null && currentJoin !== null) {
			println(currentExp)
			println(currentJoin.operator)
			println(currentJoin.exp)
			if (currentJoin.exp.aux !== null || currentExp.aux !== null) {
				if (currentExp.aux !== null && !expMap.containsKey(currentExp)) {
					evaluate(currentExp.aux.exp, currentExp, expMap);
				}
				if (currentJoin.exp.aux !== null && !expMap.containsKey(currentJoin.exp)) {
					evaluate(currentJoin.exp.aux.exp, currentJoin.exp, expMap);
				}
				if (currentJoin.exp.aux !== null && currentExp.aux !== null) {
					if (boolOps.contains(currentJoin.operator)) {
						if(expMap.get(currentExp) !== 'bool' || expMap.get(currentJoin.exp) !== 'bool') {
							error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
						}
					} else if (intOps.contains(currentJoin.operator)) {
						if(expMap.get(currentExp) !== 'int' || expMap.get(currentJoin.exp) !== 'int') {
							error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
						}
					}
				} else if (currentJoin.exp.aux !== null && currentExp.aux === null) {
					if ((boolOps.contains(currentJoin.operator) && 
						(expMap.get(currentJoin.exp) !== 'bool' || currentExp.boolean === null)) ||
						(intOps.contains(currentJoin.operator) && 
						(expMap.get(currentJoin.exp) !== 'int' || currentExp.arit === null))
					) {
						error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
					}
				} else {
					if ((boolOps.contains(currentJoin.operator) && 
						(expMap.get(currentExp) !== 'bool' || currentJoin.exp.boolean === null)) ||
						(intOps.contains(currentJoin.operator) && 
						(expMap.get(currentExp) !== 'int' || currentJoin.exp.arit === null))
					) {
						error('Operação inválida.', 
							GoPackage.Literals.EXP__AUX,
							MISMATCHED_TYPE)
					}
				}
			}
			//println('op: ' + currentJoin.operator);
			currentExp = currentJoin.exp
			currentJoin = currentExp.join
			if (currentExp.aux !== null) {
				currentJoin = currentExp.aux.join
			}
		}
	}
	
	@Check
	def checkDecl(Decl decls) {
		
	}
	
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GoPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
}
